Group A
Iteration 1
Code Feedback/Review

		All group members should read all of this feedback.  Sometimes I say things about
		one class that apply to several other classes that I don't mention.
		This file was created in notepad, so the indenting may only look okay in notepad (even then it's not pretty).
		
		This feedback goes along with a sample refactoring, which is in a tag in your project repository. Be sure
		to examine this tag to understand some of my comments and to see other things I did to the code.  There are
		comments here that didn't make it into my refactoring, and refactoring that didn't make it into the comments.

		You may merge code from my refactoring with your code, but you'll have to carefully merge rather than just
		replacing, as you've gone ahead with development since iteration 1 was due.

		Your code quality mark will be based on the comments below, but I will give no further detail as justification
		for the mark (such as how many points deducted for which particular problems).
		I will derive and release these marks as soon as I can review another group's code.

		I will give this kind of review twice in the semester to each group, so you will get
		2 reviews on 4 iterations.  I will not say which group gets reviewed when.  Do not expect you next review to
		be as detailed; I do what I can reasonably accomplish in the time I have.  This review (and associated refactoring)
		took me approximately two long days (~10 hrs each) of work.

		There will also be group accomplishment and teamwork parts to the total mark.  But remember, the course is
		about good, solid, professional code, not about zooming to the finish line with features.  Poor, fragile,
		unprofessional code is not something a professional should produce.


Formatting:  All files have inconsistency with having a space or not before a curly brace, except
		AILogic
		GameEventListener
		IPeg
		ChooseModeScene
		ChooseSizeScene
		GameOptionsScene
		Main
		TurnListener
	     (Three of those files are short interfaces.)  This is *way* too much inconsistency with such a simple thing.
		At least the UI people mostly had it together on this.
	     Java standard is a space before the curly brace, on the same line as the controlling statement/construct.

	     Curly placement on different line than controlling syntax:
		GameMode
		NullPeg
	     Was the style enforcer not checking things?


	     Some files have across-the-screen sectioning comments:
		between every pair of methods:
			HumanPlayer
		almost between every pair of methods:
			AIPlayer
			ChainGameUI
		just two, to set off the constructor:
			Hole
		some of 'em at the top, then none at the bottom:
			Main
	     I call them sectioning comments because they visually divide the file into sections.  One per method is excessive.
	     I use them only on files that are getting large, to show some structure in the code--to divide the methods into groups.
	     McConnell hates them, and doesn't want to see them at all.
	     Decide on a standard for your project and stick to it.

	     Too much vertical space, and inconsistent vertical space:
		ChooseModeScene
		ChooseSizeScene
		GameOptionsScene


development issues:
	     Magic constants found in:
		ChooseModeScene
		ChooseSizeScene
		GamePlayScene
		
	     "TODO: Auto-generated constructor stub" comment left in PegEvent.  Don't leave this kind of comment in.  Make the
		constructor correct and remove the comment.
	     Same with the "hard-coded int values, Refactor them later" comment in GamePlayScene.  (The TODOs in initialize() there
		are somewhat acceptable, being tasks that require interaction with other classes and therefore more thought.)

	     No toString() methods found.  Didn't I say this was one of the first things to consider (after immutability) in
	     designing a class?  It makes debugging life easier.

	     Uses three classes that act as points--java.awt.Point, PlayerMove, and HoleButton.  Standardize and/or use composition (has-a relationships).
		


I've put names beside classes that I was told were owned by these individuals.

Alex:	AbstractPlayer (rename to Player, or make an interface named player with the interface to this class)
	PlayerMove - Given that the project already uses java.awt.point, why have another mutable point class, with
		     code to maintain?
		     std. mutable point class; since setX and setY are used only in two spots, 
		     make this class immutable and construct a new one in HumanPlayer.processEvent:
				nextMove = new PlayerMove(pegEvent.getX(), pegEvent.getY());
		     Use a null/default object instead of the nilary (no-argument) constructor,
		     and have a static factory nullInstance() for it to use in the initializations in HumanPlayer
		     and AIPlayer (where the nilary constructor is called right now).
		     Other options than immutability: (1) make PlayerMove an empty subclass of java.awt.point
		     (this mixes layers because awt is a UI package)--(also, it gives you the name for the use of a 
		     point as a move, so if you need to add to move, you can, without changing client code), (2) eliminate
		     PlayerMove in favor of java.awt.point everywhere.
		     
		     After reading other code, I'd recommend adding the player as a field of this class.
	             If you make an immutable point, you may want to put (just the point part) in the infrastructure layer.
		     PlayerMove could then subclass or have a field with that type.  
		     
	HumanPlayer - see above, and:
		     Dealing with UI events should be done in the UI, not the domain.  The domain shouldn't know about
			windows, etc.  So processEvent doesn't really belong here.  The others methods are okay, and a
			setMove(x, y) or setNextMove(x, y) should be implemented, as should a getter for allowMoves.
			Then this class is responsible for waiting for something (from the UI, presumably) to call its
			notifyOfMove method, generally after setting the next move (but perhaps not, as in the case of a
			close request).  BTW, what does getNextMove return when there is a close request?  I waffle between
			the name "allowMoves" and the name "isWaiting" (or "isWaitingForMove"); both have their attractions. 


Glen:	Hole	  - it's a bit more abstract / easier to understand a Point (I would use java.awt.Point if you use that in other classes)
		     	than x, y: change fields to a point, and constructor args to a point, and getX/getY to getLocation().
		    the field "slot" should be "peg".
		    separate mutators from queries: have a query to see if a player can place a peg in this Hole.
				public boolean canPlace(PlayerID playerID) {
					return peg.isNull();
				}
		    this replaces hasPeg(), being its negation--change AILogic to reflect this change.
		    Also, canPlace may be able to expand to handle the edges of the board.
	
		    Add a NullObject Hole, perhaps as a nested class.  I called my static factory "offBoardInstance()", 
			indicating the intent to use it for hole locations off the board.

	IPeg/Peg/NullPeg - isNull() may not really be necessary.  Think about how to remove it.
	PlayerID -  I'm not sure about the field "value", as getOrdinal gives you that anyhow.  However,
		  	the value is used as an index in PlayerController, so one has to be careful--the default ordinals
			might not be what you want, so you may want to give explicit values to PLAYER_A and PLAYER_B
			as you have done.  UNDEFINED doesn't need an explicit value, but you'd have to write another
			constructor to allow zero arguments, which isn't worth it here.  In any event, "value" isn't a
			good name; it may as well be called "integer" for all the information it gives you.

Ian:	Board	   - discussed a lot in class. 
	Connection - I'd go with an array of Hole, rather than A and B.  Often an array is a better choice than two
			arbitrary names like this, so client code can access the names with the same sort of call:
				connection.getHole(index)
			rather than 
				if(index==0) {
					connection.getHoleA();
				}
				else {
					connection.getHoleB();
				}

Jean-Marc:  ChainGameController -  OMG.  This file is *way* too complex with *way* too deep nesting.
			Don't call javafx from the application layer.  Call it only from the UI layer.  The application
			shouldn't know about the UI. This means the threading model will be UI...
		        Inconsistent "){"  & ") {"
			List<TurnListener> depends on ui class TurnListener, a violation of layering.  Move TurnListener to this package. 
		    "getRunningState()" should be "isRunning()" & by convention, "setRunningState()" becomes "setRunning()".
	    	    To keep startGame at a consistent level of abstraction, I'd extract the gameBoard line to a method called "pepareBoard(width, height)".
		    Think about your concurrency-handling.  Can two startGame() calls execute simultaneously?  If so, could both of
			them pass the !isRunning() test, and then both end up preparing boards and players and starting the thread?  Synchronize...
		    Remove the System.out.println or send the message to a logger where you can later turn the logger off.
		    Fix the stale comment on startGame.
		    preparePlayers is too complex.  Switching on an enum can often be a smell, and it is here.  Overall, what does this method do?  It
			creates different players based on the gameMode.  Why not have the GameMode do that itself?  It is consistent with the idea of
			a GameMode--which is an object telling one what players you have.  It keeps any mess dependent on a gameMode in
			GameMode. The following is the goal for preparePlayers:
			
				private void preparePlayers(GameMode mode) {	
				    addPlayer(mode.player1());
			  	    addPlayer(mode.player2());
				}
			Now GameMode must implement player1() and player2().
			The game loop guts, inside the try block, should be extracted.  The "// catch any issue ... " comment is a 
				classic repeat-what-the-code-says comment, so it shouldn't be there.  Rather than System.out, you should
				use a logger.  The println call in the catch block is long, and might be better off if it were also extracted as a method.
			"isRunning() == true" is semantically equivalent to "isRunning()".  Don't clutter the program with extra trues.
			I see a "move != null", so it must be Null Object time.  I put a nullInstance() in PlayerMove, and we can
			assume that currentPlayer.getNextMove returns a real PlayerMove and eliminate that conditional.  (Put the else on the
			inner conditional).
			The bad-move-handling is a bit shaky here.  It prints an error message on a bad move, but then what?  It goes on to the next players and
			tells the turn listeners that a turn has happened.  Probably it should only do those other things if the move is good.
			Both PlayerMove and Point are 2D point classes; perhaps you could standardize on one of them.  Another option is to make
			PlayerMove hold not only the point but also the player.  Then gameBoard.isValidMove and gameBoard.placePeg could
			both take one argument.  Then we could eliminate the variable currentPlayer and just say 
					PlayerMove move = currentPlayer().getNextMove();
		        Anyhow, the conversion from one point class to another is grating; one could make this
			conversion into a method on PlayerMove--asPoint() is a decent standard name.  To accomplish this, first extract the "new Point(...)"
			as a method asPoint (here on ChainGameController). Then highlight that method and alt-shift-v (Move Method) and
			choose "PlayerMove" from the dialog.
			
			So in my sample refactoring I left both point classes in.  I extracted the body of the game loop, except for the sleep().
			I wonder about that sleep(); it's a fairly short one.  First off, should it instead be a yield()?
			Secondly, shouldn't the AbstractPlayer subclasses that have to wait do their own thread idling?  I'm not sure what is going on there.
 			So now the body of the game loop (attemptAMove) is still a bit long for my tastes, and I'd probably break it down further into submethods.  
			The System.out usages should be going to a logger; the first one points out that both AbstractPlayer and PlayerMove should have toString()
			methods; then it would just be "logger.log(currentPlayer + " " + move);" or some such.  (And if PlayerMove included the Player...just print the
			PlayerMove...)

	    GameMode -	one doesn't need to give values to gameModes.  They already have ordinal() if you want that.  Here, I can't
			imagine any client that would need to get a number corresponding to a GameMode. Let the GameMode itself perform
			any enum-dependent behaviour.  (That's a first-line-of-defense rule.  Sometimes the behaviour doesn't fit with
			the conception of the enum, and one is then stuck with a switch on an enum in some other class.  But try to avoid
			it with polymorphic methods.)
			player1() and player2() can be implemented either as lambdas or as a switch within the enum.  The lambda method is 
			more verbose (at the moment) but preferred (it uses polymorphism, not conditionals).  If you ever add options changing
			player1, such as a COMP_V_REMOTE, the lambda method wins.  The AbstractPlayer factories (the new java lingo is "supplier")
			are straightforward, except the AI player, which requires the board.  To avoid having to pass the board in to all
			the factories, or to call ChainGameController.getInstance() inside GameMode (adding a dependency, I think that a
			default configuration of AIPlayer to use AILogic is the way to resolve the problem.  Then one doesn't need the setAILogic()
			call to have a valid AIPlayer.

	    PlayerController - "addPlayer" is a bad name--it might overwrite an old player.  Maybe it's a setPlayer(). Better yet would be a
			setPlayers(player1, player2) as one might expect that both players are known at the start of a game.  Perhaps even better
			would be to make the players be constructor args, and build a new PlayerController for each game.  Right now, it's a
			singleton, instanced only once in the singleton ChainGameController.  Then one might include a "replacePlayer()" which
			would be equivalent to your "addPlayer".  In general, do not instance objects without making them fully functional.  It's
			more complicated to deal with an object protocol that is:
					Cow cow = new Cow();
					cow.initX(some args);
					cow.initY(some more args);
			rather than just:
					Cow cow = new Cow(some args, some more args).
			Often the new-init protocol causes bugs where objects get malformed by someone calling the new but then 
			never calling the init.  Also, new-init is much riskier in a multithreaded environment. So, at the end of a
			constructor or factory method, always have a complete, functioning object.

	    I move on to others' code rather than examine your other classes.


Justin: ChooseSizeScene - unused import ChainGameController.  Remove it.
			For my tastes, the Buttons and Pane defined at the top of the class use too much space.  I'd remove the 
			blank lines and maybe even put the annotation on the same line as the declaration.
			The blank lines all over the code are irritating.  Most of them shouldn't be there.
			This is poor formatting...did you read the formatting chapter?
			The setOnAction calls' arguments are crying out to become lambdas.  Fulfill their wishes.
			If you create a setSize(sizeX, sizeY) method, then the lambdas don't even need curly braces.
			"loadPlayerChooseModeScene" seems too long.  "loadChooseModeScene" is better; more in line with the fxml file name.
			The call to pane.getChildren().add() is formatted very strangely.  Don't break a line like this to put a single argument.
			The try block here is too long, and should be extracted. I'd put the clear() call inside the try and extract it with the other statements. 
			The extracted code is of a standard form; there's another version of it in GameOptionsScene, for example.  There should be a way to
			avoid this duplication; this is done by giving it some arguments.  First we notice that the Pane is different in the two instances,
			so we make that an argument.  Then we notice the string filename is different, so we add that as an argument, too.
			Now the name can be made more generic: loadScene(pane, fxmlFilename);  One can then break down the part that is in the try
			Since this method should exist in several object classes, we need a superclass or an interface with default methods (java 8).
			So extract loadScene to a SceneLoader class or interface. Now, note that the method called from the try block, which I called
			"triedLoadScene", can be split into two distinct operations: (1) loading the fxml file, getting the Node "root" as the outcome,
			and (2) making "root" the only child of the pane.  So extract these two methods.  Now triedLoadScene is simple enough to
			inline back into the try block.

			I don't like the confirm dialog.  That extra precaution is not needed; nothing bad happens if you choose a wrong size.

			As a design note, you should *not* be loading up the next scene in any of your scene classes; if you change the order
			or add another scene, you have to go back and make a lot of changes. There should be one place that controls the order
			that the scenes appear..maybe in ChainGameUI.  

 Matt: AIPlayer - 	Should have a default AILogic, or require it as a constructor arg.  The new-init protocol for making an object is dangerous.  
			Here I'd prefer the default route, as constructing an AILogic is arcane (unless you're the ChainGameController).
			The long "divider-line" comments are distracting, because there isn't much in each section.

       AILogic - 	Again, there's a new-init protocol (after new, you must call setPlayer to have a fully-formed object).
			More customary is to have an field or class constant Random.  Random number generators can be costly to create
			and use.  "random" is probably a better name than "randMove"...the latter implies that the variable is a move.
			The main control structure in calculateMove should be a do-while, not a while.
			Should probably change x and y to a java.awt.Point; doing this cleanly requires a new PlayerMove(point) constructor.

Parminder: 	GameOptionsScene - see my comments on ChooseSizeScene.  This class needs a lot of the same edits.  Reorder the fields
			to appear in the same order as in ChooseSizeScene (pane, then buttons).  Consistency like this is important.  Use a lambda in the
			call to setOnAction.  The action boils down to a call to loadScene. Note how these classes boil down to very
			compact and simple things.

		GamePlayScene - see general commments on javafx at the bottom of this file.
			I see you _almost_ broke javafx convention enough to get a readable name for btnGrid.  :)
			By javafx convention, this name would indicate a button that had something to do with a grid, not a grid of buttons.
			But I'd say the proper name is "buttonGrid" and this is what you naturally thought to call it.  This is an example of
			why the javafx naming conventions suck.  Good on you for "btnGrid".
			"connectionsGrid" seems an odd name for a Pane.  "btnGrid" is inside of it (according to the fxml).  What was the intent here?
			If it really should be a Pane, then it should be called "connectionsPane", or better yet, "boardPane" because it 
			includes the buttons for the holes/pegs.  Or maybe it should be a GridPane; then it would be okay to call it "connectionsGrid"
			provided it is changed to not include the buttonGrid.  I left it as it was, but it needs fixing.
			The "refactor them later" takes 10 minutes.  Why didn't you do it?  Never leave the little stuff like this around in your code.
			I made the width and height into fields, so that later you can set them to what the size scene selection was.
			The button width and height and style I made into constants.
			CreatePegs seems to create HoleButtons, not Pegs.  That makes it poorly-named.  Also, it's odd that one creates a _peg_ listener
			for a _hole_ button.
			The PegEvent mechanism doesn't seem right to me.  The domain layer shouldn't really know about events.  It should consist of functions
			that get called by event handlers. At the very bottom, I'd make it application layer; then the app layer could interpret events and
			call the right domain functions.  PegEvent isn't recognized anywhere, anyhow.  Are listeners normally named after an event, or the
			object they report to, or the object they listen to?  PegListener feels funny.
			Is GamePlayScene the right place to tell the current player to process an event?  Or is that something ChainGameController should do?
			updateBoard was too long and had an inconsistent level of abstraction.  Extracting the loop to its own method cured that.
			Do not go with the cryptic abbreviations from the javafx names as variable names (like "btn" rather than "button").
			Inside the loop formerly in updateBoard, there is a section of code that gets the hole corresponding to a button.  That should
			also be extracted, and then moved to the HoleButton class.
			This class seems too large, and it deals with a few different things...in particular, it has code for each of the
			subcomponents of the scene (buttonGrid, connectionsGrid, and endGameButton).  Because the first two of those are nontrivial,
			I'd separate them into their own classes.  However, I'm not sufficiently knowledgeable about the fxml files to be able to correctly
			do that, so in my sample refactoring I left it all in one class.  It is irritating to leave it that way, though.  
			DrawAllConnections and BuildLine are each too long; extract methods from them. 
			In buildLine, there are many magic numbers.  Make them named constants.  Also, there are three or four clear groups of statements that
			should each be extracted to a method.
			It's safer to use a switch on the enum PlayerID rather than just checking if it's the first one.  That way, you get the default case
			taken care of in the same construct.  When something can take on three values, don't just check for one of them and assume that otherwise
			you will get the second one.  Do enough conditionals that you get three cases (add and else if) or use a switch with default.

P/S/J:	Main -		inconsistent initialization of gameUI and canvas.  One is set to null, the other isn't.
			"ResizeCanvas" sounds like an operation, not a class.  Call it "ResizableCanvas" if that is accurate.
			Simplify handler specification with lambdas.
			"setupInputEvents" is okay if you're expecting more input events.  In that case, extract the one statement in it to
			a new "setupCloseEventHandler".  If you're not expecting more input events, change "setupInputEvents" to "setupCloseEventHandler".
			The gameUI argument to this method is unnecessary--often passing a field around isn't necessary (but sometimes it is).
			(oh...I dislike these objects that aren't initialized in their constructors!  But I guess it's the way javafx works.)
			initUI is long and should be broken up; obviously, it deals with three or four variables: primaryStage, root, gameUI, and canvas.
			gameUI and canvas are obvious targets for their own methods.  To effect this change, group all of the statements having to do
			with canvas into one place:
					canvas = new ResizableCanvas();
					root.getChildren().addAll(gameUI, canvas);
					canvas.widthProperty().bind(root.widthProperty());
					canvas.heightProperty().bind(root.heightProperty());

			This code has to be after the creation of root, as it uses root.  Also, the second line is also about gameUI; since that is an "addAll",
			we can break it into two "add"s and move the gameUI above these lines:
					root.getChildren().add(gameUI);
		
					canvas = new ResizableCanvas();
					root.getChildren().add(canvas);
					canvas.widthProperty().bind(root.widthProperty());
					canvas.heightProperty().bind(root.heightProperty());
			Now the four lines about canvas can be extracted, and the obvious signature for the resulting method is initCanvas(Pane root).  Use Pane
			as the type because its the highest (most general) class in StackPane's hierarchy that has a *public* getChildren().  Some day this canvas
			may be placed beneath a different parent.  A couple of classes up the hierarchy is Parent, which would be the ideal type to use, but Parent's
			getChildren is *protected*.  Another good option would be to leave the addAll alone, and move the three canvas-only lines to a
				private ResizableCanvas makeCanvas(Pane root) 
			which made a local-variable canvas and returned it.  It would be assigned to the field "canvas" in initUI.
			Next, put the gameUI creation and add-to-root statements together and extract to initGameUI.  (Or do the makeGameUI version)
			Now move the setTitle line to the other calls to primaryStage:
					StackPane root = new StackPane();

					initGameUI(root);
					initCanvas(root);

					primaryStage.setTitle("Chain Game");
					primaryStage.setScene(gameUI.getGameOptionsScene());
					primaryStage.show();			
			The primaryStage lines are now ripe for extraction.  However, note where initUI is called; setupInputEvents is called right after.
			setupInputEvents deals with setting up primaryStage as well.  So the best thing to do is to first inline initUI into start:
				public void start(Stage primaryStage) {
					StackPane root = new StackPane();
		
					initGameUI(root);
					initCanvas(root);
		
					primaryStage.setTitle("Chain Game");
					primaryStage.setScene(gameUI.getGameOptionsScene());
					primaryStage.show();
					setupInputEvents(primaryStage);
				}
			and now extract the four bottom lines to initStage or setupStage.
			And looking at those four lines, maybe we want to setup the input handlers before we show the stage...
			The other thing that bugs me a little about start now is that there is no clear indication that initGameUI must
			be performed before initStage.  This could be made a little more obvious by grouping the first three lines into
			"initComponents" or "initSubcomponents", but to make it truly clear would require passing gameUI into initStage,
			and perhaps using the "makeX" versions I described above.
			What I don't know about javafx is if the canvas (or root) here is ever used.  It's (1) connected to the root, and (2) the root is 
			connected to the gameUI, and (3) the gameUI's GameOptionScreen is connected to the stage.  But those connections are
			(1) up a hierarchy, (2) down a hierarchy, (3) possibly a weak connection through a screen that's somehow part of a ChainGameUI.
			I guess the real connections are made with the .fxml files, but this "two sets of file that could have connections" setup makes debugging
			quite difficult.
			
Sara:	ChooseModeScene - See my comments on ChooseSizeScene and GameOptionsScene.  There are many ways to extract methods to boil the handle() routine
			  down to something more manageable.  I've done some of that in the example revision.
			  The mechanism for attaching the loaded Parent "root" to the UI framework is different here than in those other two Scenes I just mentioned.
			  Why is it different, and could it be made about the same?
			  I know that the part that ended up in configureStage() is a different functionality from the others, but why does this
			  class go through the event source to get its stage and scene whereas the others go directly to the Pane defined in their class.

			  Never have mystery numbers in code.  Create named constants.

------------------------------------------------------------------------------------------------------------------------
	Seeing the javafx classes I've seen here, I'd break with javafx convention, which appears to be to encode the
	type as a prefix to the variable names.  I don't mind the type at the end of the variable name, if it is written out
	and it flows off the tongue.  So "paneGameOptions" becomes "gameOptionsPane" and "btnNewGame" becomes "newGameButton".
	I'd also change the cryptic name of the methods that set event handlers.  I've done these sort of edits in several classes
	in my branch.

	I've also changed some of the .fxml files to correspond to the new variable names.
			
